export const metadata = {
  title: "POC 0: Multiplayer Foundation",
  description: "Building reliable multiplayer sync for cooperative gameplay. The foundation that every other system depends on.",
}

## The Problem We're Solving

Before destructible walls, heat systems, or Super encounters, we need the boring thing: two players in the same world, moving smoothly.

The core problem is latency. Your input has to go to a server and back — typically 20-150ms depending on distance. If you wait for confirmation, movement feels sluggish. If you move immediately, you might be wrong. This POC builds the smallest system that resolves that tension between responsiveness and authority in co-op movement sync.

<Anchor id="concepts-in-60-seconds" />
## Concepts in 60 Seconds

Three terms you'll need:

**Authority** — A single source of truth. One entity determines what's correct when multiple versions of state exist.

**Prediction** — Acting on assumptions before confirmation. Making decisions based on expected outcomes rather than waiting for verification.

**Interpolation** — Estimating intermediate values between known data points. Smoothly filling gaps between discrete updates.

The pattern: pick an authority; predict yourself; interpolate everyone else.

<Anchor id="why-multiplayer-is-hard" />
## Why Multiplayer is Hard

### The Fundamental Problem: Latency

Press "move forward" on your keyboard. That input travels through wires to a server and back. That round trip is **latency** (or **RTT** — round-trip time). <PerplexityLink query="network latency in multiplayer games explained" />

One note on language: in this POC, when we say "server," we mean "the authoritative machine." In co-op, that's usually the host.

**Try it for yourself** — click the demo, hold WASD, and flip between 0ms, 50ms, 100ms, 150ms, 200ms.

<LatencyDemo />

If you felt that "dead air" between intent and motion, that's the whole problem. Here's a rough mapping from RTT to how it reads in your hands:

| Latency | Experience |
|---------|------------|
| 50ms | Movement feels immediate |
| Below 100ms | Feels instant |
| 150ms | Slight delay |
| 200ms | Requires aggressive techniques; without them, feels like 200ms delay — unplayable |
| 300ms | Noticeable lag |

This is the whole game: make movement feel immediate without clients disagreeing about what's true.

<AccordionSection title="The history of multiplayer networking" value="content">

The techniques we use today were pioneered in the 1990s and refined through decades of iteration. <PerplexityLink query="history of multiplayer game networking quake half-life" />

**1996: Quake and the birth of client-server**

John Carmack's Quake was one of the first games to implement true client-server architecture over the internet. Before Quake, most multiplayer games used peer-to-peer or LAN-only approaches. Carmack documented his approach in his famous `.plan` files, which became foundational texts for game networking. <PerplexityLink query="john carmack quake networking .plan files" />

**1999-2001: Half-Life and lag compensation**

Valve's GoldSrc engine (used for Half-Life, Counter-Strike) introduced sophisticated lag compensation — the server would "rewind time" to check if a player's shot actually hit where they were aiming, accounting for their latency. This made high-ping players competitive. Yahn Bernier presented the technique at GDC 2001 in "Leveling the Playing Field." ([Valve lag compensation docs](https://developer.valvesoftware.com/wiki/Lag_compensation)) <PerplexityLink query="valve lag compensation how it works counter-strike" />

**2014-2015: Gaffer on Games**

Glenn Fiedler's "Gaffer on Games" articles provide detailed technical explanations of networking concepts. His articles on [Networked Physics](https://gafferongames.com/post/introduction_to_networked_physics/) (published November 28, 2014) and [State Synchronization](https://gafferongames.com/post/state_synchronization/) (published January 5, 2015) remain essential reading for understanding modern game networking.

**2006-2010: Source Engine refinements**

Valve's Source engine (Half-Life 2, Team Fortress 2, Left 4 Dead) refined these techniques further. Their [Source Multiplayer Networking](https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking) documentation is one of the best public explanations of production networking.

**2006-2019: GGPO and rollback renaissance**

Fighting games pioneered rollback netcode (predicting inputs rather than waiting for confirmation). GGPO was first released in late 2006 by Tony Cannon and made open source in October 2019. While overkill for our co-op game, understanding rollback helps appreciate the tradeoff space. <PerplexityLink query="GGPO rollback netcode explained fighting games" />

</AccordionSection>

<Anchor id="understanding-the-options" />
## Understanding the Options

There are three common shapes for multiplayer networking. Each makes different tradeoffs around where **authority** lives and what breaks first. <PerplexityLink query="peer to peer vs client server multiplayer game architecture" />

### Option 1: Peer-to-Peer (P2P)

Every player's machine talks directly to every other player's machine. No central server. <PerplexityLink query="peer to peer networking in games pros cons" />

**How it works:**
```
Player A ←→ Player B
    ↕           ↕
Player C ←→ Player D
```

| Pros | Cons |
|------|------|
| No server costs | N² connections (scales poorly) |
| Lower latency for nearby players | No authority (who resolves conflicts?) |
| Works offline/LAN | Cheating is trivial (your machine decides what's true) |
| | NAT traversal is painful |

<PerplexityLink query="NAT traversal hole punching multiplayer games" />

### Option 2: Host-Authoritative (Listen Server)

One player's machine acts as both a player and the authority. Other players connect to them. <PerplexityLink query="listen server host migration multiplayer games" />

**How it works:**
```
Player B → Host (Player A) ← Player C
               ↓
           Player D
```

| Pros | Cons |
|------|------|
| No server costs | Host disconnect ends session (or requires migration) |
| One authoritative source of truth | Host's internet quality affects everyone |
| Works well for co-op (no fairness concerns) | Host's CPU/upload becomes bottleneck |
| Simple to implement and deploy | |

### Option 3: Client-Server (Dedicated Server)

A dedicated server owns the game state. All players are equal clients. <PerplexityLink query="dedicated server architecture multiplayer games" />

**How it works:**
```
Player A → Server ← Player B
              ↓
          Player C
```

| Pros | Cons |
|------|------|
| Consistent experience for all players | Requires server infrastructure |
| Server can persist state, handle reconnects | Server costs money |
| Better for matchmaking at scale | Added complexity |
| Professional hosting options (Hathora, etc.) | |

### Which approach for Echelon?

| Option | Who is the authority? | What you pay | What breaks first |
|--------|------------------------|--------------|-------------------|
| P2P | Nobody (state is negotiated) | No servers to run (but networking complexity) | Clients disagree about what's true |
| Host-auth (listen server) | The host | Host is a single point of failure | Host disconnects or can't keep up |
| Dedicated server | A server you run | Infra + ops cost | Shipping/operating servers becomes the work |

Echelon has heat systems, AI guards, and objectives — shared systems where everyone needs to agree on what's true. If one player sees 80% heat and another sees 50%, the game breaks.

**Constraints:** This is co-op, not competitive. We don't need competitive-grade fairness guarantees. We need one **authority** that keeps the session consistent, and movement that feels immediate. <PerplexityLink query="why host auth is fine for coop and why you should switch to dedicated for pvp" />

**Failure mode:** Divergent shared state breaks co-op trust. If clients disagree about objectives or heat levels, coordination fails.

**For Echelon, host-authoritative is the right default.** It gives us one source of truth without standing up dedicated infrastructure. The tradeoff is that we accept a single point of failure: the host's internet/CPU affects everyone, and if they leave the session ends. Host migration can mitigate this. <PerplexityLink query="host migration listen server co-op games how it works" />

**Out of scope (for now):** Dedicated infrastructure, competitive anti-cheat, matchmaking at scale.

<Anchor id="the-key-concepts" />
## Making Host-Auth Feel Good

We've chosen host-authoritative. Now we need three techniques to make it feel responsive: splitting authority, predicting your own movement, and interpolating everyone else.

### Technique 1: Authority Split

The host owns critical game state — health, inventory, objectives, AI positions. If a client says "I completed the objective," the host ignores it. The host decides what's true. <PerplexityLink query="server authority vs client authority multiplayer games" />

But if the host owns *everything*, movement feels laggy for remote players. So we split: clients predict some things locally (their own movement, visual effects), while the host remains authoritative and can correct.

**The boundary:** Host-authoritative for critical state (objectives, heat, AI), client-predictive for responsiveness (your movement, visual feedback). The host can always override.

<AccordionSection title="Why never trust the client" value="trust">

If the client tells the host "I completed the objective," a cheater can just send that message without actually doing anything.

The correct pattern:

1. Client sends: "I'm interacting with the terminal"
2. Host validates: Is the player near the terminal? Is the terminal hackable?
3. Host runs the interaction (10-second timer, host-side)
4. Host broadcasts: "Objective complete"

The client can show progress UI locally, but the host decides when it's done.

<PerplexityLink query="why never trust the client game security cheating" />

</AccordionSection>

### Technique 2: Client-Side Prediction

**Prediction** solves the responsiveness problem: press forward → you move immediately → host confirms later. The client doesn't wait. <PerplexityLink query="client side prediction multiplayer games how it works" />

If the host says "actually, you collided with something," the client corrects smoothly — sliding to the correct position rather than snapping (snapping causes visible jitter).

This is why movement can feel instant even at 150ms latency. The client predicts, the host confirms, corrections happen smoothly.

**Try it yourself** — toggle prediction on/off and feel the difference. With prediction off, you wait for the host. With prediction on, you move immediately while the host state trails behind.

<PredictionDemo />

<AccordionSection title="What can and can't be predicted" value="predict">

**Can be predicted:**
- Your own movement (most common)
- Weapon firing animations
- Visual feedback (hit markers, effects)

**Cannot be predicted:**
- Damage dealt (host calculates)
- Inventory changes (host authoritative)
- Objective state (host authoritative)
- Other players' actions (you don't know what they'll do)

<PerplexityLink query="input buffer client prediction server reconciliation" />

</AccordionSection>

### Technique 3: Interpolation

**Prediction** works for your own movement — but you can't predict other players. You don't know what they'll do. <PerplexityLink query="interpolation vs extrapolation multiplayer games networking" />

You also can't update their position every frame (60 times per second) — that's too much bandwidth. Instead, the host sends snapshots periodically, maybe 20-30 times per second. Between snapshots, clients **interpolate** — smoothly blending between the last known positions.

```
Host sends:  [t=0, x=0] ........ [t=100ms, x=10] ........ [t=200ms, x=20]
Client shows:  x=0, x=1, x=2, x=3... x=10, x=11, x=12... x=20
```

The client fills in the gaps. Without interpolation, remote players teleport every 50ms. With interpolation, they move smoothly.

**The pattern:** You predict yourself, you interpolate everyone else. Your character feels instant. Teammates appear smooth but slightly delayed.

**See the difference** — watch an NPC move on the server (left) vs how a remote client renders it (right). Toggle between snapping and interpolation, adjust update frequency and latency. Without interpolation, movement looks choppy. With interpolation, it's smooth.

<InterpolationDemo />

<AccordionSection title="How Left 4 Dead 2 handles this" value="l4d2">

Left 4 Dead 2's Source engine runs at 30 ticks per second. Clients receive snapshots and interpolate between them. ([Valve Source Multiplayer Networking docs](https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking)) <PerplexityLink query="left 4 dead 2 source engine networking tick rate" />

Left 4 Dead 2 uses dedicated servers, but the same patterns apply to host-authoritative: the authoritative machine (server or host) sends snapshots, and clients interpolate between them.

For AI zombies, the authoritative machine is fully authoritative — clients just render where it says zombies are. All players see zombies in the same positions, critical for co-op.

For player movement, clients predict their own movement but interpolate teammates. Your character feels instant. Teammates appear smooth but slightly delayed.

</AccordionSection>

---
## Conclusion

We've named the hard parts: latency, a single authority, and the techniques that keep co-op feeling good (predict yourself, interpolate everyone else).

Now that we understand the tradeoffs, we can build it.

## Resources

- [Gaffer on Games: Networked Physics](https://gafferongames.com/post/introduction_to_networked_physics/) (Nov 28, 2014) — Essential concepts
- [Gaffer on Games: State Synchronization](https://gafferongames.com/post/state_synchronization/) (Jan 5, 2015) — Detailed implementation patterns
- [Valve: Source Multiplayer Networking](https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking) — Production-grade patterns
- [Gabriel Gambetta: Fast-Paced Multiplayer](https://www.gabrielgambetta.com/client-server-game-architecture.html) — Interactive explanations with diagrams
