export const metadata = {
  title: "POC 0: Multiplayer Foundation (Draft)",
  description:
    "A primer on divergence, latency, and the techniques we’ll use in Echelon: authority, prediction, and interpolation.",
}

## The Problem We're Solving

Before destructible walls, heat systems, or Super encounters, we need the boring thing: two players in the same world, moving smoothly.

This POC is the smallest networking foundation for co-op movement: keep players in agreement about what’s true, while keeping controls feeling immediate.

If we can’t do *this*, everything else (AI, objectives, destruction) becomes a pile of edge cases.

#### Learn more

- <PerplexityLink query="history of multiplayer game networking quake half-life source engine gaffer ggpo" variant="callout">History of multiplayer games</PerplexityLink>

---

<Anchor id="why-multiplayer-is-hard" />
## Why Multiplayer is Hard

Multiplayer feels hard for two reasons. They’re related, but not the same problem.

### Problem 1: Divergence (state sync)

In multiplayer, multiple machines simulate the “same” world.

They’ll diverge. Always.

Inputs arrive at different times. <PerplexityLink query="floating point determinism multiplayer games" variant="inline">Floating point math</PerplexityLink> isn’t perfectly deterministic across machines. Randomness, physics resolution order, and frame rate differences compound. If each player trusts their local simulation as truth, you don’t have *a* world. You have multiple worlds that only look similar at first.

Here’s the smallest failure:

- Player A pushes a crate left.
- Player B pushes the same crate right.
- Both simulations produce a “reasonable” result.
- Now the crate is in two places.

That’s what <PerplexityLink query="desync multiplayer games what it is causes" variant="inline">desync</PerplexityLink> really is. Not lag. Disagreement.

Get it wrong, and you don’t get “a bit of jank.” You get a trust break: players can’t coordinate because they’re reacting to different realities.

#### Learn more

- <PerplexityLink query="lockstep networking determinism vs state sync tradeoffs" variant="callout">Lockstep vs state sync (tradeoffs)</PerplexityLink>
- <PerplexityLink query="deterministic physics multiplayer games why hard" variant="callout">Determinism in physics sims (why it’s hard)</PerplexityLink>
- <PerplexityLink query="floating point determinism cross platform game networking" variant="callout">Floating point determinism across machines</PerplexityLink>

### Problem 2: Latency (time to agreement)

Even if we pick a single truth, everyone still has to *learn* that truth over the network.

Your input has to travel to the machine deciding truth and back. That round trip is <PerplexityLink query="network latency in multiplayer games explained" variant="inline">latency</PerplexityLink> (or **RTT** — round-trip time).

**Try it for yourself** — click the demo, hold WASD, and flip between 0ms, 50ms, 100ms, 150ms, 200ms.

<LatencyDemo />

If you felt “dead air” between intent and motion, that’s latency showing up in your hands.

| Latency | Experience |
|---------|------------|
| 50ms | Movement feels immediate |
| Below 100ms | Feels instant |
| 150ms | Slight delay |
| 200ms | Requires aggressive techniques; without them, unplayable |
| 300ms | Noticeable lag |

So we’re boxed in:

- If we wait for agreement, input feels sluggish.
- If we don’t wait, clients can be wrong.

One more gotcha: steady latency is manageable. <PerplexityLink query="network jitter multiplayer games feel worse than ping" variant="inline">Jitter</PerplexityLink> (latency variation) is what makes movement feel unstable.

#### Learn more

- <PerplexityLink query="tick rate vs update rate vs frame rate multiplayer networking" variant="callout">Tick rate vs update rate vs frame rate</PerplexityLink>
- <PerplexityLink query="network jitter buffer multiplayer games interpolation buffer" variant="callout">Jitter buffers and render delay</PerplexityLink>
- <PerplexityLink query="packet loss multiplayer games prediction interpolation strategies" variant="callout">Packet loss: what breaks and how games cope</PerplexityLink>

---

## The Solutions (Concepts You Can Use)

Each solution maps to a problem above. This section stays conceptual. The next section shows how we apply it to Echelon.

### Solution to Divergence: Authority

**Authority** is the rule that <PerplexityLink query="authoritative server game networking definition" variant="inline">decides what counts as truth</PerplexityLink> when simulations disagree.

In practice, it means a single machine is “the authority” for some slice of state. When there’s a conflict, the authority wins.

Terminology we’ll use:

- **Authority**: the rule/process for resolving disagreement
- **Authoritative machine**: the computer running that rule
- **Host-authoritative**: the host player’s machine is the authoritative machine (common in co-op)
- **Dedicated server**: a separate machine is the authoritative machine (common at scale / competitive)

Authority isn’t the whole system. It’s the foundation that makes agreement possible.

### Solution to Latency (for you): Client-Side Prediction

**Prediction** is letting the client act immediately, based on what it expects the authority will decide.

You move now. The authority confirms later. If you were wrong, you correct (often called <PerplexityLink query="client-side prediction server reconciliation input buffer replay" variant="inline">server reconciliation</PerplexityLink>).

This trades one failure mode (sluggish controls) for another (corrections). The goal is to make corrections rare and, when they happen, visually cheap.

When it goes wrong, you feel it as <PerplexityLink query="rubber banding smoothing reconciliation techniques" variant="inline">rubber-banding</PerplexityLink>.

<PredictionDemo />

### Solution to Latency (for others): Interpolation

You can’t predict other players. You don’t know what they’ll do.

Instead, the authority sends snapshots periodically. Clients render other entities by <PerplexityLink query="interpolation snapshots multiplayer games how it works" variant="inline">interpolating</PerplexityLink> between snapshots: “smooth the gaps between known points.”

<InterpolationDemo />

The rule of thumb:

- Predict yourself
- Interpolate everyone else

---

<Anchor id="understanding-the-options" />
## Applied to Echelon

Now we make this real for Echelon. We pick where authority lives, what authority owns, and what clients are allowed to fake for responsiveness.

### Where does authority live?

There are three common shapes for multiplayer networking. Each makes different tradeoffs around where authority lives and what breaks first. <PerplexityLink query="peer to peer vs listen server vs dedicated server tradeoffs" variant="callout">Compare the three shapes</PerplexityLink>.

#### Option 1: Peer-to-Peer (P2P)

No central authority. Everyone talks to everyone.

What breaks first: disagreement. When two peers simulate differently, you need negotiation, <PerplexityLink query="rollback netcode explained" variant="inline">rollback</PerplexityLink>, or a conflict-resolution scheme. Complexity rises fast.

Also: <PerplexityLink query="NAT traversal games hole punching STUN TURN" variant="inline">NAT traversal</PerplexityLink> tends to be the first practical wall you hit in the real world.

#### Option 2: Host-Authoritative (Listen Server)

One player hosts and also acts as the authoritative machine.

What breaks first: the host. If they disconnect, the session ends (unless you implement <PerplexityLink query="host migration listen server how it works" variant="inline">host migration</PerplexityLink>). If their upload/CPU can’t keep up, everyone feels it.

#### Option 3: Dedicated Server

A separate machine runs the authority.

What breaks first: shipping/operating servers becomes the work (infra, cost, deployment, ops).

### Decision (for now)

Echelon is co-op. The failure cost isn’t “competitive fairness.” The failure cost is shared-state divergence: heat, objectives, AI, and destruction must stay consistent or the game stops making sense.

**Default: host-authoritative.** One source of truth, no infrastructure to stand up. We accept the host as the bottleneck and single point of failure. <PerplexityLink query="listen server host authoritative co-op games why it works" variant="callout">Why listen servers work for co-op</PerplexityLink>.

**Out of scope (for now):** matchmaking at scale, dedicated infra, competitive anti-cheat.

### What does authority own vs what do clients fake?

Authority should own shared state that affects coordination:

- Objective state
- Heat levels
- AI decisions and positions
- Destruction results

Clients should be allowed to fake responsiveness where the authority can later correct safely:

- Your own movement
- Visual feedback (effects, animations, UI)

#### Learn more

- <PerplexityLink query="never trust the client authoritative server validation patterns" variant="callout">Never trust the client (validation patterns)</PerplexityLink>
- <PerplexityLink query="authoritative server validate intent vs outcome multiplayer games" variant="callout">Intent vs outcome: what clients can say</PerplexityLink>
- <PerplexityLink query="game networking cheating prevention authoritative server basics" variant="callout">Cheat prevention basics in an authoritative model</PerplexityLink>

---

## Conclusion

Multiplayer breaks because simulations diverge, and agreement arrives late.

Authority solves divergence. Prediction and interpolation make latency tolerable.

Part 2 turns these concepts into an implementation.

## Resources

- [Gaffer on Games: Networked Physics](https://gafferongames.com/post/introduction_to_networked_physics/) (Nov 28, 2014) — Essential concepts
- [Gaffer on Games: State Synchronization](https://gafferongames.com/post/state_synchronization/) (Jan 5, 2015) — Detailed implementation patterns
- [Valve: Source Multiplayer Networking](https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking) — Production-grade patterns
- [Gabriel Gambetta: Fast-Paced Multiplayer](https://www.gabrielgambetta.com/client-server-game-architecture.html) — Interactive explanations with diagrams

