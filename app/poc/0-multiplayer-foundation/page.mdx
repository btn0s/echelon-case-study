export const metadata = {
  title: "POC 0: Multiplayer Foundation",
  description: "Building reliable multiplayer sync for cooperative gameplay. The foundation that every other system depends on.",
}

# POC 0: Multiplayer Foundation

## The Problem We're Solving

Before we can build destructible walls, heat systems, or Super encounters, we need two players to exist in the same world.

Multiplayer networking is the foundation that every other system depends on. Get it wrong, and players see different worlds. Get it really wrong, and the game feels unplayable — laggy, inconsistent, frustrating. This POC establishes the networking layer that POCs 1-7 will build upon.

**What we're validating:** Can we build reliable multiplayer sync that feels responsive for cooperative gameplay?

**TL;DR**
- **Architecture:** Dedicated client-server (server authoritative)
- **Prototype stack:** PartyKit (server) + WebSockets + React Three Fiber (rendering)
- **Movement model:** local movement updates immediately, remote players interpolate between network snapshots
- **Network target:** send movement ~20Hz, render at frame rate
- **Done when:** two clients can connect/reconnect and see each other move smoothly under ~150ms RTT
- **Out of scope (for this POC):** input sequencing/reconciliation, anti-cheat, authoritative physics sync

**Note:** POC 0 uses transform broadcast (clients send position/rotation directly). True input-based prediction with server reconciliation comes in later POCs.

## How to Use This Guide

We're going to deep dive on multiplayer networking fundamentals — why latency matters, how client-server architecture works, and the concepts that make responsive multiplayer possible. This context will help you understand *why* we make each implementation choice.

**What's ahead:**
- Why multiplayer networking is fundamentally hard (latency, authority, consistency)
- The three main architectural approaches and their tradeoffs  
- Core concepts: authority, prediction, interpolation
- Our stack choices and why they fit Echelon
- Step-by-step implementation with code walkthroughs

The implementation section assumes you understand these concepts, but you can always circle back if something doesn't make sense.

**Want to skip straight to building?** Jump to [Step-by-Step Implementation](#step-by-step-implementation).

<a id="why-multiplayer-is-hard"></a>
## Why Multiplayer is Hard

### The Fundamental Problem: Latency

When you press "move forward" on your keyboard, light travels through wires to a server, the server processes your input, and light travels back. Even at the speed of light, this takes time — typically 20-150ms depending on distance. <PerplexityLink query="network latency in multiplayer games explained" />

For a single-player game, this is irrelevant. For a multiplayer game, it creates a paradox:

- If you wait for server confirmation before showing movement, the game feels sluggish
- If you show movement immediately, you might be wrong about where you actually are
- If two players interact with the same object, who wins?

Every multiplayer game in history has had to solve this problem. The solutions are well-documented, but choosing the right approach for your game requires understanding the tradeoffs.

<AccordionSection title="The history of multiplayer networking" value="content">

The techniques we use today were pioneered in the 1990s and refined through decades of iteration. <PerplexityLink query="history of multiplayer game networking quake half-life" />

**1996: Quake and the birth of client-server**

John Carmack's Quake was one of the first games to implement true client-server architecture over the internet. Before Quake, most multiplayer games used peer-to-peer or LAN-only approaches. Carmack documented his approach in his famous `.plan` files, which became foundational texts for game networking. <PerplexityLink query="john carmack quake networking .plan files" />

**1999-2001: Half-Life and lag compensation**

Valve's GoldSrc engine (used for Half-Life, Counter-Strike) introduced sophisticated lag compensation — the server would "rewind time" to check if a player's shot actually hit where they were aiming, accounting for their latency. This made high-ping players competitive. Yahn Bernier presented the technique at GDC 2001 in "Leveling the Playing Field." ([Valve lag compensation docs](https://developer.valvesoftware.com/wiki/Lag_compensation)) <PerplexityLink query="valve lag compensation how it works counter-strike" />

**2014-2015: Gaffer on Games**

Glenn Fiedler's "Gaffer on Games" articles provide detailed technical explanations of networking concepts. His articles on [Networked Physics](https://gafferongames.com/post/introduction_to_networked_physics/) (published November 28, 2014) and [State Synchronization](https://gafferongames.com/post/state_synchronization/) (published January 5, 2015) remain essential reading for understanding modern game networking.

**2006-2010: Source Engine refinements**

Valve's Source engine (Half-Life 2, Team Fortress 2, Left 4 Dead) refined these techniques further. Their [Source Multiplayer Networking](https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking) documentation is one of the best public explanations of production networking.

**2006-2019: GGPO and rollback renaissance**

Fighting games pioneered rollback netcode (predicting inputs rather than waiting for confirmation). GGPO was first released in late 2006 by Tony Cannon and made open source in October 2019. While overkill for our co-op game, understanding rollback helps appreciate the tradeoff space. <PerplexityLink query="GGPO rollback netcode explained fighting games" />

</AccordionSection>

<a id="understanding-the-options"></a>
## Understanding the Options

There are three fundamental approaches to multiplayer networking. Each makes different tradeoffs between complexity, consistency, and responsiveness. <PerplexityLink query="peer to peer vs client server multiplayer game architecture" />

### Option 1: Peer-to-Peer (P2P)

Every player's machine talks directly to every other player's machine. No central server. <PerplexityLink query="peer to peer networking in games pros cons" />

**How it works:**
```
Player A ←→ Player B
    ↕           ↕
Player C ←→ Player D
```

| Pros | Cons |
|------|------|
| No server costs | N² connections (scales poorly) |
| Lower latency for nearby players | No authoritative state (who's right when players disagree?) |
| Works offline/LAN | Cheating is trivial (your machine decides what's true) |
| | NAT traversal is painful <PerplexityLink query="NAT traversal hole punching multiplayer games" /> |

**Used by:** Older fighting games, some indie games, local multiplayer

### Option 2: Host-Authoritative (Listen Server)

One player's machine acts as both player and server. Other players connect to them. <PerplexityLink query="listen server host migration multiplayer games" />

**How it works:**
```
Player B → Host (Player A) ← Player C
               ↓
           Player D
```

| Pros | Cons |
|------|------|
| No dedicated server needed | Host has zero latency (unfair advantage in competitive games) |
| Simpler than full client-server | If host disconnects, game ends (or requires migration) |
| Works for small player counts | Host's internet quality affects everyone |

**Used by:** Payday 2, Deep Rock Galactic, many co-op games

### Option 3: Client-Server (Dedicated Server)

A dedicated server owns the game state. All players are equal clients. <PerplexityLink query="dedicated server architecture multiplayer games" />

**How it works:**
```
Player A → Server ← Player B
              ↓
          Player C
```

| Pros | Cons |
|------|------|
| Consistent experience for all players | Requires server infrastructure |
| Server can validate/prevent cheating | Added complexity |
| Server can persist state, handle reconnects | Server costs money |
| Professional hosting options (Hathora, etc.) | |

**Used by:** Counter-Strike, Fortnite, most competitive games

### Which approach for Echelon?

| Factor | P2P | Host-Auth | Client-Server |
|--------|-----|-----------|---------------|
| Fairness | No authority | Host advantage | Equal for all |
| Cheating | Easy | Host can cheat | Server validates |
| Complexity | Simple | Medium | Higher |
| Cost | Free | Free | Server costs |
| Reconnection | Hard | Host migration | Clean reconnect |

**Our choice: Client-Server**

Echelon needs consistent state for heat systems, AI guards, and objectives. We can't have players seeing different heat levels or objective states. Client-server gives us the foundation to build authoritative game systems.

For development, we'll use a simple WebSocket server. For production, we could use [Hathora](https://hathora.dev/), [Colyseus Cloud](https://colyseus.io/), or self-host. <PerplexityLink query="game server hosting options hathora colyseus 2024" />

<a id="the-key-concepts"></a>
## The Key Concepts

Before we start building, we need to internalize three concepts that will guide every networking decision.

### Concept 1: Authority

**Authority** means "who is the source of truth for this piece of state?" <PerplexityLink query="server authority vs client authority multiplayer games" />

For critical game state, the server is authoritative:
- Heat level (POC 2)
- Objective completion (POC 4)
- Guard positions (POC 3)
- Player health
- Inventory

For responsiveness, the client can *predict* some outcomes locally (while the server remains authoritative and can correct):
- Player movement (in POC 0, we update locally and broadcast transforms; true prediction with reconciliation comes in later POCs)
- Visual effects (cosmetic only)

<Alert title="Never trust the client for critical state">

If the client tells the server "I completed the objective," a cheater can just send that message without actually completing anything. 

The correct pattern:
1. Client sends: "I'm interacting with the terminal"
2. Server validates: Is the player near the terminal? Is the terminal hackable?
3. Server runs the interaction: 10-second timer, server-side
4. Server broadcasts: "Objective complete"

The client can show progress UI locally, but the server decides when it's actually done.

<PerplexityLink query="why never trust the client game security cheating" />

</Alert>

### Concept 2: Client-Side Prediction

**Prediction** means the client immediately shows the result of player actions without waiting for server confirmation. <PerplexityLink query="client side prediction multiplayer games how it works" />

When you press "forward":
1. **Without prediction:** Press key → wait 100ms → server confirms → you move (feels laggy)
2. **With prediction:** Press key → you move immediately → server confirms later (feels responsive)

The catch: sometimes you'll be wrong. The server might say "actually, you collided with something" or "actually, you were stunned." When that happens, you need to correct smoothly.

**POC 0 note:** This POC uses a simplified approach — local movement updates immediately and we broadcast transforms. True input-based prediction with sequence numbers and server reconciliation is deferred to later POCs (see the Alert section below for details).

<AccordionSection title="How prediction actually works" value="content">

**The input buffer pattern:** <PerplexityLink query="input buffer client prediction server reconciliation" />

```typescript
// Client sends inputs with sequence numbers
const input = { seq: 42, keys: { forward: true, right: false }, dt: 0.016 }
sendToServer(input)

// Client also predicts locally
localPlayer.position.add(calculateMovement(input))

// Server processes and sends authoritative state
// { seq: 42, position: { x: 10, y: 0, z: 5 }, ... }

// Client compares predicted position to server position
// If different, smoothly correct (interpolate, don't snap)
```

**What can be predicted:**
- Movement (most common)
- Weapon firing animations
- Visual feedback (hit markers, etc.)

**What should NOT be predicted:**
- Damage dealt (server calculates)
- Inventory changes (server authoritative)
- Objective state (server authoritative)
- Other players' actions (you can't predict them)

</AccordionSection>

### Concept 3: Interpolation and Snapshots

**Interpolation** is how we make other players (and networked objects) move smoothly despite only receiving updates 20-30 times per second. <PerplexityLink query="interpolation vs extrapolation multiplayer games networking" />

The server sends "snapshots" of game state periodically. Between snapshots, clients interpolate — smoothly blending between the last known positions.

```
Server sends:  [t=0, x=0] ........ [t=100ms, x=10] ........ [t=200ms, x=20]
Client shows:  x=0, x=1, x=2, x=3... x=10, x=11, x=12... x=20
```

This introduces a small delay (an interpolation buffer, typically 1-2 snapshot periods or ~100ms+) to absorb network jitter and ensure smooth movement. The buffer trades a small amount of latency for visual smoothness.

<AccordionSection title="Left 4 Dead 2 (co-op with AI sync)" value="example">

Left 4 Dead 2's Source engine runs the server at 30 ticks per second for most gameplay (this tickrate is fixed and cannot be altered without causing server timing issues). Clients receive snapshots and interpolate between them. ([Valve Source Multiplayer Networking docs](https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking)) <PerplexityLink query="left 4 dead 2 source engine networking tick rate" />

For AI zombies, the server is fully authoritative — clients just render where the server says zombies are. This ensures all players see zombies in the same positions, which is critical for cooperative gameplay.

For player movement, clients predict their own movement but interpolate other players. This means your own character feels instant, while teammates appear smooth but slightly delayed.

The key insight: **you only predict yourself, you interpolate everyone else.**

</AccordionSection>

## Our Stack

We're building with the pmndrs (Poimandres) ecosystem — React Three Fiber for 3D rendering, with a WebSocket-based networking layer. <PerplexityLink query="pmndrs poimandres react three fiber ecosystem" />

### Core Technologies

**React Three Fiber (R3F)**
The React renderer for Three.js. Lets us build 3D scenes with React components. We'll use this for all game rendering. <PerplexityLink query="react three fiber vs vanilla threejs pros cons" />

**Zustand**
Minimal state management from the pmndrs ecosystem. R3F uses it internally, and we'll use it for local game state. Note: Zustand is client-side only — we need networking to sync between clients. <PerplexityLink query="zustand state management react three fiber" />

**WebSockets**
The transport layer for real-time communication. We have options for the server: <PerplexityLink query="websocket vs webrtc for multiplayer games" />

| Option | Complexity | Best For |
|--------|------------|----------|
| [PartyKit](https://partykit.io/) | Low | Quick prototypes, edge deployment |
| [Socket.io](https://socket.io/) | Medium | Traditional WebSocket server |
| [Colyseus](https://colyseus.io/) | Medium-High | Game-specific features (rooms, state sync) |
| [Hathora](https://hathora.dev/) | Medium | Production game hosting |

**For this POC, we'll use PartyKit** — it's the fastest way to get a WebSocket server running, has excellent DX, and deploys to Cloudflare's edge network. 

**Important nuance:** PartyKit rooms are backed by Cloudflare Durable Objects, which are instantiated in a single location (optionally influenced by `locationHint`). This means a room provides low latency when players are near that location, but doesn't automatically distribute globally. For co-op games with players in the same region, this works well. For global distribution, you'd need region-specific rooms or a different approach. <PerplexityLink query="partykit websocket edge deployment tutorial" />

### Relevant Resources

**Tutorials:**
- [Wawa Sensei: Multiplayer R3F with Socket.io](https://wawasensei.dev/tuto/build-a-multiplayer-game-with-react-three-fiber-and-socket-io) — 7-part series building a Sims-like multiplayer game
- [Maya Nedeljković Batić: R3F + WebSocket Game](https://www.maya-ndljk.com/talks/r3f-websocket-game) — Conference talk with code

**Foundational Reading:**
- [Gaffer on Games: Networked Physics](https://gafferongames.com/post/introduction_to_networked_physics/) (Nov 28, 2014) — Essential concepts
- [Gaffer on Games: State Synchronization](https://gafferongames.com/post/state_synchronization/) (Jan 5, 2015) — Detailed implementation patterns
- [Valve: Source Multiplayer Networking](https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking) — Production-grade patterns
- [Gabriel Gambetta: Fast-Paced Multiplayer](https://www.gabrielgambetta.com/client-server-game-architecture.html) — Interactive explanations with diagrams

**Libraries:**
- [PartyKit](https://partykit.io/) — Edge-deployed WebSocket server (backed by Cloudflare Durable Objects)
- [Playroom Kit](https://joinplayroom.com/) — Multiplayer React hooks (alternative approach)
- [@react-three/rapier](https://github.com/pmndrs/react-three-rapier) — Physics, which we'll need to sync in POC 1

## What We're Building

This POC is intentionally minimal. We're not building a game — we're building the foundation and validating it works.

### The Test Scenario

Two players connect to a shared 3D space. Each player can move around. Both players see each other's movements in real-time.

That's it. No shooting, no objectives, no physics. Just movement sync.

**Why so minimal?**

Movement sync is the canary in the coal mine. If we can't make two players see each other moving smoothly, everything else will fail. By keeping scope minimal, we can:

1. Focus entirely on networking correctness
2. Measure latency and consistency precisely
3. Iterate quickly on the foundation
4. Build confidence before adding complexity

### Success Criteria

| Criteria | Target | How We'll Measure |
|----------|--------|-------------------|
| Connection reliability | 99%+ | Connect/disconnect 100 times, count failures |
| Movement consistency | No visible desync | Record both screens, compare |
| Latency tolerance | < 150ms feels good | Artificial latency testing |
| Reconnection | Works within 10s | Disconnect WiFi, reconnect, verify state |

<a id="step-by-step-implementation"></a>
## Step-by-Step Implementation

> **Building without context?** If you skipped ahead, you might want to understand [why multiplayer is hard](#why-multiplayer-is-hard), [the architectural options](#understanding-the-options), and [core concepts](#the-key-concepts) before diving in. But you can always circle back.

### Step 1: Set Up PartyKit Server

PartyKit gives us a WebSocket server that deploys to Cloudflare's edge network. <PerplexityLink query="partykit cloudflare workers websocket server setup" />

The server is the authoritative source of truth. It maintains game state, validates player actions, and broadcasts updates to all connected clients. PartyKit's `room.storage` provides persistent state that survives server restarts, deployments, and hibernation — critical for a multiplayer game where players need to rejoin seamlessly. ([PartyKit storage docs](https://docs.partykit.io/guides/persisting-state-into-storage/))

**What we're building:**
- A server that tracks all players in a room
- Connection lifecycle handlers (connect, message, disconnect)
- Message routing that broadcasts state changes to all clients
- Persistent storage so players can rejoin and see the current game state

**Why PartyKit:**
- Edge deployment provides low latency when rooms are placed near players (via Cloudflare Durable Objects)
- Built-in room management handles WebSocket connections automatically
- `room.storage` provides persistent state without a database (survives restarts/hibernation)
- TypeScript-first API with excellent DX

**Durable Objects location note:** Each room is backed by a Durable Object instantiated in a single data center location. You can influence placement with `locationHint`, but objects don't auto-migrate. This works well for co-op games where players are in the same region. ([Cloudflare DO data location docs](https://developers.cloudflare.com/durable-objects/reference/data-location/))

Create `party/main.ts` and start with the types and interfaces:

```typescript
// party/main.ts
import type { PartyKitServer, PartyConnection } from "partykit/server"

type Vec3 = { x: number; y: number; z: number }

interface Player {
  id: string
  position: Vec3
  rotation: number
}

interface GameState {
  players: Record<string, Player>
}
```

Now add the `onConnect` handler — this runs when a player joins:

```typescript
export default {
  async onConnect(connection: PartyConnection, room) {
    // Load existing state or create new
    const state =
      (await room.storage.get<GameState>("state")) ?? ({ players: {} } satisfies GameState)
    
    // Create new player at spawn point
    const player: Player = {
      id: connection.id,
      position: { x: 0, y: 0.5, z: 0 },
      rotation: 0,
    }
    state.players[connection.id] = player
    
    // Send current game state to the new player
    connection.send(JSON.stringify({
      type: "init",
      playerId: connection.id,
      players: Object.values(state.players),
    }))
    
    // Tell everyone else about the new player
    room.broadcast(JSON.stringify({
      type: "player-joined",
      player,
    }), [connection.id]) // Exclude the new player from this broadcast
    
    await room.storage.put("state", state)
  },
```

Add the `onMessage` handler for movement updates:

```typescript
  async onMessage(message: string, connection: PartyConnection, room) {
    const data = JSON.parse(message)
    const state =
      (await room.storage.get<GameState>("state")) ?? ({ players: {} } satisfies GameState)
    
    if (data.type === "move") {
      const player = state.players[connection.id]
      if (player) {
        // Update authoritative position (no validation in POC 0)
        state.players[connection.id] = {
          ...player,
          position: data.position,
          rotation: data.rotation,
        }
        
        // Broadcast to all clients
        room.broadcast(JSON.stringify({
          type: "player-moved",
          playerId: connection.id,
          position: data.position,
          rotation: data.rotation,
        }))
      }
    }
    
    await room.storage.put("state", state)
  },
```

Finally, add the `onClose` handler for disconnections:

```typescript
  async onClose(connection: PartyConnection, room) {
    const state =
      (await room.storage.get<GameState>("state")) ?? ({ players: {} } satisfies GameState)
    delete state.players[connection.id]
    
    room.broadcast(JSON.stringify({
      type: "player-left",
      playerId: connection.id,
    }))
    
    await room.storage.put("state", state)
  },
} satisfies PartyKitServer
```

The server is now the authoritative source of truth — it owns `GameState`, validates actions, and broadcasts updates to all clients.

<Alert title="POC simplification: we're sending transforms, not inputs">

For POC 0, clients send their **position/rotation** ("state sync") because it's the fastest way to validate connectivity + interpolation. This is not secure and it won't hold up for authoritative physics.

In later POCs, we'll send **inputs + sequence numbers** and reconcile client prediction against the server's simulation.

</Alert>

### Step 2: Client Connection Hook

A React hook to manage the WebSocket connection and state. <PerplexityLink query="react websocket hook pattern real time state" />

This hook encapsulates all the networking logic on the client side. It handles connection lifecycle, message parsing, state updates, and provides a clean API for components to use. The hook returns the current connection state, all players, and a function to send movement updates.

**Why a custom hook:**
- Separates networking concerns from UI components
- Makes it easy to test networking logic independently
- Provides a consistent API that multiple components can use
- Handles all the WebSocket event listeners in one place

**State management approach:**
We're using React's `useState` with a `Map` for players. This gives us O(1) lookups by player ID, avoiding O(n) array searches when we have many players. The state updates immutably — we create new Maps on each update to trigger React re-renders.

Create `hooks/useMultiplayer.ts` with types and initial state:

```typescript
// hooks/useMultiplayer.ts
import { useState } from "react"
import usePartySocket from "partysocket/react"

interface Player {
  id: string
  position: { x: number; y: number; z: number }
  rotation: number
}

interface MultiplayerState {
  connected: boolean
  playerId: string | null
  players: Map<string, Player>
}

export function useMultiplayer(roomId: string) {
  const [state, setState] = useState<MultiplayerState>({
    connected: false,
    playerId: null,
    players: new Map(),
  })
```

Set up the WebSocket connection with lifecycle handlers:

```typescript
  const socket = usePartySocket({
    host: process.env.NEXT_PUBLIC_PARTYKIT_HOST!,
    room: roomId,
    
    onOpen() {
      setState(prev => ({ ...prev, connected: true }))
    },
```

Handle incoming messages — start with the `init` message:

```typescript
    onMessage(event) {
      const data = JSON.parse(event.data)
      
      switch (data.type) {
        case "init":
          setState(prev => ({
            ...prev,
            playerId: data.playerId,
            players: new Map(data.players.map((p: Player) => [p.id, p])),
          }))
          break
```

Add handlers for player join/leave:

```typescript
        case "player-joined":
          setState(prev => {
            const players = new Map(prev.players)
            players.set(data.player.id, data.player)
            return { ...prev, players }
          })
          break
          
        case "player-left":
          setState(prev => {
            const players = new Map(prev.players)
            players.delete(data.playerId)
            return { ...prev, players }
          })
          break
```

Handle movement updates:

```typescript
        case "player-moved":
          setState(prev => {
            const players = new Map(prev.players)
            const previous = players.get(data.playerId)
            if (!previous) return { ...prev, players }

            players.set(data.playerId, {
              ...previous,
              position: data.position,
              rotation: data.rotation,
            })
            return { ...prev, players }
          })
          break
      }
    },
```

Add disconnect handler and return the API:

```typescript
    onClose() {
      setState(prev => ({ ...prev, connected: false }))
    },
  })
  
  const sendMove = (position: { x: number; y: number; z: number }, rotation: number) => {
    socket.send(JSON.stringify({ type: "move", position, rotation }))
  }
  
  return { ...state, sendMove }
}
```

The hook encapsulates all networking logic and provides a clean API: connection state, player list, and a function to send movement updates.

### Step 3: Game Scene with Player Rendering

The React Three Fiber scene that renders all players. <PerplexityLink query="react three fiber multiplayer scene rendering players" />

This component ties everything together. It uses the `useMultiplayer` hook to get connection state and player data, then renders a 3D scene with React Three Fiber. The key insight here is the distinction between `LocalPlayer` and `RemotePlayer` — they handle movement differently because one is controlled locally (with prediction) and the others are observed remotely (with interpolation).

**Scene setup:**
We're using a simple scene with ambient and directional lighting, a ground plane for reference, and OrbitControls so we can move the camera around. The ground plane helps visualize movement — players move on the XZ plane (horizontal), with Y being up.

**Player rendering logic:**
The component maps over all players and conditionally renders either `LocalPlayer` or `RemotePlayer` based on whether the player ID matches the current client's ID. This is the critical split: your own player gets prediction, everyone else gets interpolation.

Create `components/MultiplayerScene.tsx`:

```tsx
// components/MultiplayerScene.tsx
import { Canvas } from "@react-three/fiber"
import { OrbitControls } from "@react-three/drei"
import { useMultiplayer } from "@/hooks/useMultiplayer"
import { LocalPlayer } from "./LocalPlayer"
import { RemotePlayer } from "./RemotePlayer"

export function MultiplayerScene({ roomId }: { roomId: string }) {
  const { connected, playerId, players, sendMove } = useMultiplayer(roomId)
  
  if (!connected) {
    return <div>Connecting...</div>
  }
```

Set up the 3D scene with lighting and ground:

```tsx
  return (
    <Canvas camera={{ position: [0, 10, 10] }}>
      <ambientLight intensity={0.5} />
      <directionalLight position={[10, 10, 5]} />
      
      <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0, 0]}>
        <planeGeometry args={[20, 20]} />
        <meshStandardMaterial color="#333" />
      </mesh>
```

Render players — split local vs remote:

```tsx
      {Array.from(players.values()).map(player => (
        player.id === playerId ? (
          <LocalPlayer 
            key={player.id}
            initialPosition={player.position}
            onMove={sendMove}
          />
        ) : (
          <RemotePlayer
            key={player.id}
            player={player}
          />
        )
      ))}
      
      <OrbitControls />
    </Canvas>
  )
}
```

**Key distinction:** `LocalPlayer` handles input and prediction (you control it), while `RemotePlayer` interpolates from network updates (you observe it). This separation is fundamental — your character needs immediate feedback, while others need smooth interpolation.

### Step 4: Local Player with Prediction

The local player predicts movement immediately, then sends to server. <PerplexityLink query="client side prediction implementation javascript" />

Create `components/LocalPlayer.tsx` with setup:

```tsx
// components/LocalPlayer.tsx
import { useRef } from "react"
import { useFrame } from "@react-three/fiber"
import { useKeyboardControls } from "@react-three/drei"
import * as THREE from "three"

interface LocalPlayerProps {
  initialPosition: { x: number; y: number; z: number }
  onMove: (position: { x: number; y: number; z: number }, rotation: number) => void
}

export function LocalPlayer({ initialPosition, onMove }: LocalPlayerProps) {
  const meshRef = useRef<THREE.Mesh>(null)
  const positionRef = useRef(new THREE.Vector3(
    initialPosition.x, 
    0.5,
    initialPosition.z
  ))
  const lastSentRef = useRef(0)
  
  const [, getKeys] = useKeyboardControls()
```

Add movement logic in `useFrame`:

```tsx
  useFrame((_, delta) => {
    if (!meshRef.current) return
    
    const { forward, backward, left, right } = getKeys()
    const speed = 5
    const movement = new THREE.Vector3()
    
    // Calculate movement direction
    if (forward) movement.z -= 1
    if (backward) movement.z += 1
    if (left) movement.x -= 1
    if (right) movement.x += 1
    
    if (movement.length() > 0) {
      movement.normalize().multiplyScalar(speed * delta)
      positionRef.current.add(movement)
      
      // Update mesh immediately (prediction)
      meshRef.current.position.copy(positionRef.current)
```

Throttle network updates to ~20Hz:

```tsx
      // Send to server at ~20Hz (not every frame)
      const now = Date.now()
      if (now - lastSentRef.current > 50) {
        onMove(
          { x: positionRef.current.x, y: positionRef.current.y, z: positionRef.current.z },
          meshRef.current.rotation.y
        )
        lastSentRef.current = now
      }
    }
  })
```

Render the mesh:

```tsx
  return (
    <mesh ref={meshRef} position={[initialPosition.x, 0.5, initialPosition.z]}>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color="blue" />
    </mesh>
  )
}
```

**Key patterns:** Movement updates immediately (prediction), network updates throttled to ~20Hz, position stored in ref to avoid re-renders. We normalize the direction vector to ensure consistent speed regardless of diagonal movement.

### Step 5: Remote Player with Interpolation

Remote players interpolate smoothly between network updates. <PerplexityLink query="lerp interpolation smooth movement game networking" />

Create `components/RemotePlayer.tsx`:

```tsx
// components/RemotePlayer.tsx
import { useRef, useEffect } from "react"
import { useFrame } from "@react-three/fiber"
import * as THREE from "three"

interface Player {
  id: string
  position: { x: number; y: number; z: number }
  rotation: number
}

export function RemotePlayer({ player }: { player: Player }) {
  const meshRef = useRef<THREE.Mesh>(null)
  const targetPosition = useRef(new THREE.Vector3(
    player.position.x,
    0.5,
    player.position.z
  ))
```

Update target position when network updates arrive:

```tsx
  // Update target when we receive network updates
  useEffect(() => {
    targetPosition.current.set(
      player.position.x,
      0.5,
      player.position.z
    )
  }, [player.position])
```

Interpolate smoothly each frame:

```tsx
  // Smoothly interpolate toward target
  useFrame((_, delta) => {
    if (!meshRef.current) return
    
    // Lerp toward target position (~100ms smoothing)
    meshRef.current.position.lerp(targetPosition.current, Math.min(1, delta * 10))
  })
```

Render the mesh:

```tsx
  return (
    <mesh ref={meshRef} position={[player.position.x, 0.5, player.position.z]}>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color="red" />
    </mesh>
  )
}
```

**Key patterns:** Target position updates from network, current position lerps toward target each frame. The `delta * 10` smoothing factor (~100ms) balances responsiveness with jitter reduction. Higher values are snappier but jittery; lower values are smoother but laggy.

---

## What We'll Learn From This

After building and testing this minimal multiplayer foundation, we should be able to answer:

1. **Latency tolerance:** At what RTT does movement start feeling laggy?
2. **Update frequency:** Is 20Hz enough, or do we need higher? <PerplexityLink query="tick rate update frequency multiplayer games optimal" />
3. **Interpolation quality:** Does lerp-based interpolation look smooth?
4. **Connection handling:** How quickly can we detect and handle disconnects?
5. **State recovery:** Can players rejoin seamlessly?

These answers will inform every subsequent POC:
- **POC 1 (Destruction):** How do we sync physics events? <PerplexityLink query="syncing physics destruction multiplayer games" />
- **POC 2 (Heat):** Is server-authoritative heat responsive enough?
- **POC 3 (AI):** Can we sync guard positions at acceptable bandwidth?
- **POC 4 (Objectives):** How do we handle objective interaction timing?

## Instrumentation

We need to measure what matters: <PerplexityLink query="measuring network latency jitter multiplayer games" />

```typescript
// Metrics to track
interface NetworkMetrics {
  rtt: number           // Round-trip time in ms
  jitter: number        // RTT variance
  updateRate: number    // Updates received per second
  bytesPerSecond: number
  disconnects: number
  reconnectTime: number // ms to successfully reconnect
}
```

We'll add a debug overlay showing these metrics in real-time, and log aggregated data for analysis.

## Open Questions

Things we'll discover during implementation:

- Should we use delta compression or full snapshots? <PerplexityLink query="delta compression vs full snapshots game networking" />
- How do we handle the first few frames before interpolation has data?
- What's the right smoothing factor for interpolation?
- Should we add extrapolation (predicting where remote players are going)? <PerplexityLink query="extrapolation dead reckoning multiplayer games" />
- How do we visualize connection quality to players?

## Next Steps

Once this POC is complete and validated:

1. **Document decisions:** What tick rate, what interpolation approach, what worked
2. **Create shared utilities:** Connection hooks, player sync components
3. **Move to POC 1:** Add physics and test destruction sync

The foundation we build here will carry through the entire project. Take time to get it right.
